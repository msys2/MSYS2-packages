diff --git a/bashline.c b/bashline.c
index 8f69bc6..6d285c5 100644
--- a/bashline.c
+++ b/bashline.c
@@ -822,7 +822,11 @@ snarf_hosts_from_file (filename)
   char *temp, buffer[256], name[256];
   register int i, start;
 
-  file = fopen (filename, "r");
+#ifdef __MSYS__
+  file = fopen (filename, "rt");
+#else
+   file = fopen (filename, "r");
+#endif
   if (file == 0)
     return;
 
diff --git a/builtins/fc.def b/builtins/fc.def
index 9b8a997..5be93bd 100644
--- a/builtins/fc.def
+++ b/builtins/fc.def
@@ -681,6 +681,10 @@ fc_readline (stream)
      FILE *stream;
 {
   register int c;
+#ifdef __MSYS__
+  register int d;
+#endif
+
   int line_len = 0, lindex = 0;
   char *line = (char *)NULL;
 
@@ -691,12 +695,19 @@ fc_readline (stream)
 
       if (c == '\n')
 	{
+#ifdef __MSYS__
+	  if (d == '\r')
+	    lindex--;
+#endif
 	  line[lindex++] = '\n';
 	  line[lindex++] = '\0';
 	  return (line);
 	}
       else
 	line[lindex++] = c;
+#ifdef __MSYS__
+      d = c;
+#endif
     }
 
   if (!lindex)
diff --git a/general.c b/general.c
index f4c2a2f..0ae74ca 100644
--- a/general.c
+++ b/general.c
@@ -818,7 +818,8 @@ int
 absolute_program (string)
      const char *string;
 {
-  return ((char *)mbschr (string, '/') != (char *)NULL);
+  return ((char *)mbschr (string, '/') != (char *)NULL ||
+          (char *)mbschr (string, '\\') != (char *)NULL);
 }
 
 /* **************************************************************** */
diff --git a/lib/readline/display.c b/lib/readline/display.c
index c1135ec..b388af6 100644
--- a/lib/readline/display.c
+++ b/lib/readline/display.c
@@ -529,7 +529,10 @@ expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)
   if (lp)
     *lp = rl;
   if (lip)
-    *lip = last;
+    /* Hack: faking that the last character is invisible seems to work around
+       prompt display bugs.  I wish I knew what the real bug was...  */
+    *lip = r - ret;
+/*     *lip = last; */
   if (niflp)
     *niflp = invfl;
   if  (vlp)
diff --git a/parse.y b/parse.y
index 8fd24a1c..232a33dc 100644
--- a/parse.y
+++ b/parse.y
@@ -1459,7 +1459,13 @@ yy_input_name ()
 static int
 yy_getc ()
 {
-  return (*(bash_input.getter)) ();
+#ifdef __MSYS__
+  int c;
+  while ((c = (*(bash_input.getter)) ()) == '\r');
+  return c;
+#else
+   return (*(bash_input.getter)) ();
+#endif
 }
 
 /* Call this to unget C.  That is, to make C the next character
@@ -1684,7 +1690,15 @@ rewind_input_string ()
      into account, e.g., $(...\n) */
   xchars = shell_input_line_len - shell_input_line_index;
   if (bash_input.location.string[-1] == '\n')
-    xchars++;
+    {
+      xchars++;
+#ifdef __MSYS__
+      {
+	if (bash_input.location.string[-2] == '\r')
+	  xchars++;
+      }
+#endif
+    }
 
   /* XXX - how to reflect bash_input.location.string back to string passed to
      parse_and_execute or xparse_dolparen? xparse_dolparen needs to know how
diff --git a/shell.c b/shell.c
index ee9d445..8f25726 100644
--- a/shell.c
+++ b/shell.c
@@ -1696,7 +1696,11 @@ open_shell_script (script_name)
   default_buffered_input = fd;
   SET_CLOSE_ON_EXEC (default_buffered_input);
 #else /* !BUFFERED_INPUT */
-  default_input = fdopen (fd, "r");
+#ifdef __MSYS__
+  default_input = fdopen (fd, "rt");
+#else
+   default_input = fdopen (fd, "r");
+#endif
 
   if (default_input == 0)
     {
diff --git a/stringlib.c b/stringlib.c
index 7330496..8623fa6 100644
--- a/stringlib.c
+++ b/stringlib.c
@@ -278,7 +278,15 @@ strip_trailing (string, len, newlines_only)
     {
       if ((newlines_only && string[len] == '\n') ||
 	  (!newlines_only && whitespace (string[len])))
+      {
 	len--;
+#ifdef __MSYS__
+	if (newlines_only && string[len + 1] == '\n' && string[len] == '\r')
+	{
+	  len--;
+	}
+#endif
+      }
       else
 	break;
     }
diff --git a/subst.c b/subst.c
index 2001b4e..3ba2029 100644
--- a/subst.c
+++ b/subst.c
@@ -6895,6 +6895,15 @@ read_comsub (fd, quoted, flags, rflag)
 	      /* If the newline was quoted, remove the quoting char. */
 	      if (istring[istring_index - 1] == CTLESC)
 		--istring_index;
+
+	      if (istring_index > 0 && istring[istring_index - 1] == '\r')
+	      {
+		--istring_index;
+
+	        /* If the caret return was quoted, remove the quoting char. */
+	        if (istring[istring_index - 1] == CTLESC)
+		  --istring_index;
+	      }
 	    }
 	  else
 	    break;
diff --git a/tests/crlf.right b/tests/crlf.right
new file mode 100644
index 0000000..d7fd195
--- /dev/null
+++ b/tests/crlf.right
@@ -0,0 +1,8 @@
+Line with LF
+Line with CR
+Line with CRLF
+Line with
+ LF
+Line with CR
+Line with
+ CRLF
diff --git a/tests/crlf.tests b/tests/crlf.tests
new file mode 100644
index 0000000..b2c4da7
--- /dev/null
+++ b/tests/crlf.tests
@@ -0,0 +1,6 @@
+echo $(echo -e "Line with\n LF")
+echo $(echo -e "Line with\r CR")
+echo $(echo -e "Line with\r\n CRLF")
+echo "$(echo -e "Line with\n LF")"
+echo "$(echo -e "Line with\r CR")"
+echo "$(echo -e "Line with\r\n CRLF")"
diff --git a/tests/ps1lf.right b/tests/ps1lf.right
new file mode 100644
index 0000000..ee83131
--- /dev/null
+++ b/tests/ps1lf.right
@@ -0,0 +1,2 @@
+foo
+$ exit
diff --git a/tests/ps1lf.tests b/tests/ps1lf.tests
new file mode 100644
index 0000000..01a2265
--- /dev/null
+++ b/tests/ps1lf.tests
@@ -0,0 +1 @@
+PS1='$(echo foo)\n\$ '
diff --git a/tests/run-crlf b/tests/run-crlf
new file mode 100644
index 0000000..3f6037c
--- /dev/null
+++ b/tests/run-crlf
@@ -0,0 +1,2 @@
+${THIS_SH} ./crlf.tests > ${BASH_TSTOUT}
+diff ${BASH_TSTOUT} crlf.right && rm -f ${BASH_TSTOUT}
diff --git a/tests/run-ps1lf b/tests/run-ps1lf
new file mode 100644
index 0000000..1617108
--- /dev/null
+++ b/tests/run-ps1lf
@@ -0,0 +1,2 @@
+${THIS_SH} --rcfile ./ps1lf.tests -i < /dev/null 2>&1 | tr -d '\r' > ${BASH_TSTOUT}
+diff ${BASH_TSTOUT} ps1lf.right && rm -f ${BASH_TSTOUT}
diff --git a/variables.c b/variables.c
index 028667c..a10594d 100644
--- a/variables.c
+++ b/variables.c
@@ -2593,6 +2593,20 @@ set_if_not (name, value)
 {
   SHELL_VAR *v;
 
+#if defined (__MSYS__)
+  /* Remove trailing \r from value */
+  {
+    char *tpos;
+    if (value && *value)
+    {
+      tpos = strchr (value, '\0');
+      tpos--;
+      if (*tpos == '\r')
+	*tpos = '\0';
+    }
+  }
+#endif
+
   if (shell_variables == 0)
     create_variable_tables ();
 
